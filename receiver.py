# Copyright (c) 2015 Fraunhofer FOKUS. All rights reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #





import base64
import json
import logging
import subprocess
import traceback
from git import Repo, GitCommandError
import os
import psutil

__author__ = 'lto,ogo'



log = logging.getLogger(__name__)
#the environmental variable SCRIPTS_PATH is set everytime the script-path was contained in the json message, you can use after you cloned or saved the script
SCRIPTS_PATH = "/opt/openbaton/scripts"


def on_message(message):

        #log.info('received a message: %s' % message)
        try:
            dict_msg = json.loads(message)

            action = dict_msg.get('action')

            payload = dict_msg.get('payload')
        except ValueError: #this section deals with the case when the message is not a json message and as a result cannot be processed. Considering that the messages are generated by the NFVO this is not supposed to happen
            print "Not a json object"
            action = None
            out = None
            err = "Not a json message"
            status = "1"
        if action == 'SAVE_SCRIPTS':
            path = dict_msg.get('script-path')
            try:
                script = base64.b64decode(payload)

                if path == None:
                    print "No path provided, saving into default directory"
                    path = SCRIPTS_PATH
                if not os.path.exists(path):
                    os.makedirs(path)
                name = dict_msg.get('name')

                if path[-1] == "/":
                    path_name = path + name
                else:
                    path_name = path + "/" + name

                os.environ['SCRIPTS_PATH'] = path
                f = open(path_name, "w")
                f.write(script)
                log.info("Written %s into %s" % (script, path_name))
                out = str(os.listdir(path))
                err = ""
                status = 0
                st = os.stat(path)
                os.chmod(path, st.st_mode | 0111)
                st = os.stat(path_name)
                os.chmod(path_name, st.st_mode | 0111)
            except TypeError: #catches typeerror in case of the message not being properly encoded
                print "Incorrect script encoding"
                action = None
                out = None
                err = "Incorrect script encoding"
                status = "1"

        if action == 'CLONE_SCRIPTS':
            path = dict_msg.get('script-path')
            if path == None:
                path = SCRIPTS_PATH
            url = payload
            os.environ['SCRIPTS_PATH'] = path
            log.debug("Cloning into: %s" % url)
            try:
                Repo.clone_from(url, path)
                print 'Cloned'
                log.debug('Cloned')
            except GitCommandError as e:
                print 'Encountered error'
                err = traceback.format_exc()
                status = e.status
                out = None
            else:
                out = str(os.listdir(path))
                err = ""
                status = 0
        elif action == "EXECUTE":
            if payload[-1] == "/":
                payload = SCRIPTS_PATH + payload
            else:
                payload = SCRIPTS_PATH + "/" + payload
            env = dict_msg.get('env')
            log.debug("Executing: %s with env %s" % (payload, env))
            if env is None or len(env) == 0:
                env = None
            else:
                env.update(os.environ)
            ems_out_log = open('/var/log/openbaton/ems-out.log', "w+")
            ems_err_log = open('/var/log/openbaton/ems-err.log', "w+")

            proc = subprocess.Popen(["/bin/bash"] + payload.split(), stdout=ems_out_log, stderr=ems_err_log, env=env)
            status = proc.wait()
            ems_out_log.seek(0)
            ems_err_log.seek(0)
            out = ems_out_log.read()
            err = ems_err_log.read()

            ems_out_log.close()
            ems_err_log.close()
            log.debug("Executed: ERR: %s OUT: %s", err, out)


        elif action == "SCRIPTS_UPDATE":
            url = payload
            try:
                Repo.pull(url, "/opt/openbaton/scripts/")
            except GitCommandError as e:
                err = traceback.format_exc()
                status = e.status
                out = None
            else:
                out = str(os.listdir(SCRIPTS_PATH))
                err = ""
                status = 0

        elif action == "GET_STATISTICS":
            url = payload
            try:
                cpu = psutil.cpu_percent()
                ram = psutil.virtual_memory().percent
                disk = psutil.disk_usage('/').percent
            except e:
                err = "cannot get stats"
                status = -1
                out = None
            else:
                out = s = 'cpu:'+str(c)+',mem:'+str(m)+',disk:'+str(d)
                err = ""
                status = 0

        if out is None:
            out = ""
        if err is None:
            err = ""

        resp = {
            'output': out,
            'err': err,
            'status': status
        }
        json_str = json.dumps(resp)
        log.info("answer is: " + json_str)
        return json_str
